这是一个非常棒的架构升级！你的需求已经从一个单纯的“脚本工具”通过“配置化”进化到了“低代码平台”，现在你要进一步将其升级为**“企业级运维工作台”**。
为了实现高扩展性、双重配置管理以及多级导航布局，我们需要彻底重构代码结构。现在的单文件模式已经无法承载这个量级了，必须采用**模块化（Modular）**设计。
我们分三步走：
 * 工程结构规划：设计解耦的文件目录。
 * 核心基建（Core）：实现双配置文件加载（组内+个人）和配置合并逻辑。
 * UI 框架（Shell）：实现你想要的主导航+子导航布局。
以下是第一阶段的实施方案：
1. 🏗️ 工程结构规划 (Architecture)
我们将项目拆分为“核心框架”和“业务模块”。
ops_platform/
├── main.py                  # [入口] 负责整体布局、模块调度
├── config.py                # [配置] 全局路径配置（如共享盘路径）
├── core/                    # [内核] 通用组件，不涉及具体业务
│   ├── __init__.py
│   ├── config_manager.py    # 负责加载/合并 双份JSON
│   └── ui_utils.py          # UI 辅助工具（统一的样式等）
└── modules/                 # [插件] 所有的功能模块放这里
    ├── __init__.py
    └── cmd_generator/       # === 你的命令生成器模块 ===
        ├── __init__.py      # 暴露模块信息
        ├── app.py           # 该模块的主UI逻辑
        └── data_handler.py  # 该模块的数据处理

2. 🧠 核心基建：双配置管理 (core/config_manager.py)
这个类负责同时读取“共享盘配置”和“本地配置”，并将它们合并。为了区分，我们会在读取时给数据打上标签（source: team 或 source: personal）。
# core/config_manager.py
import json
import os
from typing import Dict, Any

class ConfigManager:
    def __init__(self, team_path: str, user_path: str):
        self.team_path = team_path
        self.user_path = user_path

    def _load_json(self, path: str) -> Dict:
        if not os.path.exists(path):
            return {}
        try:
            with open(path, 'r', encoding='utf-8') as f:
                return json.load(f)
        except Exception as e:
            print(f"Error loading {path}: {e}")
            return {}

    def save_user_config(self, data: Dict):
        """只保存个人配置"""
        # 实际保存时，应该只保存 source='personal' 的数据
        # 这里简化处理，假设传入的就是要存的全量个人数据
        os.makedirs(os.path.dirname(self.user_path), exist_ok=True)
        with open(self.user_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, indent=4, ensure_ascii=False)

    def get_merged_templates(self) -> Dict[str, Any]:
        """
        合并策略：
        1. 读取团队配置
        2. 读取个人配置
        3. 返回一个合并后的字典。
        注意：如果同名，这里简单的让个人覆盖团队，或者你可以做成共存。
        """
        team_data = self._load_json(self.team_path)
        user_data = self._load_json(self.user_path)

        merged = {}
        
        # 1. 标记团队模版
        for name, content in team_data.items():
            content['source'] = 'team'
            content['category'] = content.get('category', '公共默认') # 默认分类
            merged[name] = content
            
        # 2. 标记个人模版 (可能会覆盖团队的同名模版)
        for name, content in user_data.items():
            content['source'] = 'personal'
            content['category'] = content.get('category', '个人默认')
            merged[name] = content
            
        return merged

3. 🎨 UI 框架：侧边栏多级导航 (main.py)
Streamlit 原生只支持一个 Sidebar。为了实现你描述的 “主导航(左侧细条) -> 子导航(展开) -> 内容”，我们需要一种稍微变通但效果很好的布局方式：
 * 主导航：使用 sidebar 顶部的 selectbox 或 radio 来切换大模块。
 * 子导航：根据主导航的选择，动态渲染 sidebar 下半部分的内容（比如分类树）。
 * 内容区：右侧主界面。
下面是 main.py 的代码，它搭建了整个平台的骨架：
# main.py
import streamlit as st
import os
from core.config_manager import ConfigManager
# 动态导入模块 (模拟解耦)
from modules.cmd_generator import app as cmd_app

# --- 全局配置 ---
# 真实场景请换成你的共享盘路径，例如 r"Z:\Shared\ops_tool\team_config.json"
TEAM_CONFIG_PATH = "team_config.json" 
USER_CONFIG_PATH = "user_config.json"

# 初始化管理器
cfg_mgr = ConfigManager(TEAM_CONFIG_PATH, USER_CONFIG_PATH)

def main():
    st.set_page_config(page_title="Ops Workstation", layout="wide", page_icon="🛠️")

    # =============================================
    # 1. 主导航栏 (Level 1 Navigation)
    # =============================================
    with st.sidebar:
        st.title("🚀 Ops Platform")
        
        # 以后如果有新模块，就在这里加
        MODULES = {
            "cmd_gen": "📝 命令生成器",
            "dashboard": "📊 监控大盘 (规划中)",
            "settings": "⚙️ 全局设置"
        }
        
        # 使用 radio 模拟左侧主导航
        selected_module_key = st.radio(
            "功能模块", 
            options=list(MODULES.keys()), 
            format_func=lambda x: MODULES[x],
            label_visibility="collapsed"
        )
        
        st.markdown("---") # 分割线

    # =============================================
    # 2. 模块分发 (Router)
    # =============================================
    if selected_module_key == "cmd_gen":
        # 进入命令生成器模块，把侧边栏的控制权交给它
        cmd_app.render(cfg_mgr)
        
    elif selected_module_key == "dashboard":
        st.title("监控大盘")
        st.info("此模块正在开发中...")
        
    elif selected_module_key == "settings":
        st.title("全局设置")
        st.write(f"团队配置路径: `{TEAM_CONFIG_PATH}`")
        st.write(f"个人配置路径: `{USER_CONFIG_PATH}`")

if __name__ == "__main__":
    main()

4. 🧩 业务模块改造 (modules/cmd_generator/app.py)
这是你需要把之前的代码逻辑迁移进来的地方。针对你提出的**“分类折叠”和“管理/使用分离”**，我为你重写了 UI 逻辑。
# modules/cmd_generator/app.py
import streamlit as st
from jinja2 import Template
import shlex
import pandas as pd

def render(cfg_mgr):
    """
    命令生成器的主入口
    cfg_mgr: 传入配置管理器实例
    """
    # 获取合并后的所有数据
    templates = cfg_mgr.get_merged_templates()
    
    # ==========================================
    # 侧边栏：子导航 (Level 2 Navigation)
    # ==========================================
    with st.sidebar:
        st.subheader("功能菜单")
        # 两个大模式
        mode = st.radio("模式选择", ["📂 模板列表", "🛠️ 管理模板"], label_visibility="collapsed")
        
        selected_template_name = None
        
        # 模式 A: 模板列表 (使用/生成)
        if mode == "📂 模板列表":
            # --- 核心需求：分类筛选 ---
            # 1. 提取所有分类
            all_categories = sorted(list(set(t.get('category', '未分类') for t in templates.values())))
            
            # 2. 渲染分类折叠菜单 (Expander)
            for cat in all_categories:
                # 找出该分类下的所有模板
                cat_templates = [name for name, t in templates.items() if t.get('category') == cat]
                
                with st.expander(f"📁 {cat} ({len(cat_templates)})", expanded=False):
                    # 在每个分类里放置按钮或单选
                    for t_name in cat_templates:
                        # 使用 button 模拟链接点击
                        if st.button(t_name, key=f"btn_{t_name}"):
                            st.session_state['current_template'] = t_name

        # 模式 B: 管理模板 (增删改) - 直接点击侧边栏不展开，右侧显示管理页
        elif mode == "🛠️ 管理模板":
            st.session_state['current_template'] = "__ADMIN__"

    # ==========================================
    # 右侧主内容区 (Main Content)
    # ==========================================
    
    current = st.session_state.get('current_template')

    if current == "__ADMIN__":
        render_admin_panel(cfg_mgr, templates)
    elif current and current in templates:
        render_generator_panel(templates[current])
    else:
        st.info("👈 请在左侧选择一个模板开始使用")

# --- 具体的渲染函数 (逻辑与之前类似，稍微封装一下) ---

def render_generator_panel(config):
    st.header(f"生成: {config.get('desc', '无描述')}")
    # 显示来源标签
    if config.get('source') == 'team':
        st.caption("🏢 团队共享模板 (只读建议)")
    else:
        st.caption("👤 个人模板")
        
    # ... (这里放之前 render_generator_ui 的表单逻辑) ...
    st.warning("此处应显示之前的表单生成逻辑，因篇幅折叠...")

def render_admin_panel(cfg_mgr, templates):
    st.header("模板管理")
    
    # 提取所有现有分类，用于下拉框自动补全
    existing_categories = sorted(list(set(t.get('category', '') for t in templates.values() if t.get('category'))))
    
    with st.expander("➕ 新增/编辑模板", expanded=True):
        c1, c2 = st.columns([1, 1])
        # 1. 分类选择 (核心需求：可选择 + 可输入)
        # Streamlit 的 selectbox 不支持直接输入新值，需用 combo box 或 text_input 配合
        # 方案：两步走，或者用 tag input。这里用最稳妥的方案：Selectbox 包含 "新建..."
        
        select_options = existing_categories + ["➕ 新建分类..."]
        cat_selection = c1.selectbox("所属分类", select_options)
        
        final_category = cat_selection
        if cat_selection == "➕ 新建分类...":
            final_category = c1.text_input("输入新分类名称", placeholder="例如: 数据库维护")
            
        name = c2.text_input("模板名称")
        
        # ... (其余参数编辑逻辑，与之前一致) ...
        st.write(f"即将保存到分类: **{final_category}**")
        st.button("保存 (示例)")

当前架构的优点：
 * 真正的解耦：main.py 不包含任何生成命令的逻辑，它只负责“路由”。以后你要加“数据库审计工具”，只需要在 modules 下新建一个文件夹，然后在 main.py 里注册两行代码。
 * 配置分离：通过 ConfigManager，你可以放心把代码部署给同事。同事的修改只会存到 user_config.json，不会污染你的 team_config.json（除非你有意合并）。
 * 符合直觉的导航：左侧大类 -> 左侧详细树状图 -> 右侧操作。
下一步建议
这只是把骨架搭好了。接下来我们需要把具体的逻辑填充进去。
你需要我先帮你完善 modules/cmd_generator/app.py 里的：
 * Generator 渲染逻辑（把之前的代码搬进来）。
 * Admin 管理逻辑（特别是如何处理 Team 配置只读、Personal 配置可写的问题）。
还是说你想先要在本地把这个目录结构建起来跑通一下？
